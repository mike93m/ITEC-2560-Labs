// node_modules/mande/dist/mande.mjs
function stringifyQuery(query) {
  let searchParams = Object.keys(query).map((k) => [k, query[k]].map(encodeURIComponent).join("=")).join("&");
  return searchParams ? "?" + searchParams : "";
}
var leadingSlashRE = /^\/+/;
function joinURL(base, url) {
  return base + (url && (base.endsWith("/") ? url.replace(leadingSlashRE, "") : url.startsWith("/") ? url : "/" + url));
}
function removeNullishValues(headers) {
  return Object.keys(headers).reduce((newHeaders, headerName) => {
    if (headers[headerName] != null) {
      newHeaders[headerName] = headers[headerName];
    }
    return newHeaders;
  }, {});
}
var defaults = {
  responseAs: "json",
  headers: {
    Accept: "application/json"
    // NOTE: instead of passing json here, we pass it when creating the request to automatically handle FormData
    // 'Content-Type': data instanceof FormData ? null : 'application/json',
  },
  stringify: JSON.stringify
};
function mande(baseURL, passedInstanceOptions = {}, fetchPolyfill) {
  function _fetch(method, urlOrDataOrOptions, dataOrOptions, localOptions = {}) {
    let url;
    let data;
    if (typeof urlOrDataOrOptions === "object") {
      url = "";
      localOptions = dataOrOptions || urlOrDataOrOptions || {};
      data = urlOrDataOrOptions;
    } else {
      url = urlOrDataOrOptions;
      data = dataOrOptions;
    }
    let mergedOptions = {
      ...defaults,
      ...instanceOptions,
      method,
      ...localOptions,
      // we need to ditch nullish headers
      headers: removeNullishValues({
        // let the browser automatically set the content-type with FormData
        "Content-Type": data instanceof FormData ? null : "application/json",
        ...defaults.headers,
        ...instanceOptions.headers,
        ...localOptions.headers
      })
    };
    let query = {
      ...defaults.query,
      ...instanceOptions.query,
      ...localOptions.query
    };
    let { responseAs } = mergedOptions;
    url = joinURL(baseURL, typeof url === "number" ? "" + url : url || "");
    url += stringifyQuery(query);
    if (method[0] === "P" && data && !mergedOptions.body) {
      mergedOptions.body = data instanceof FormData ? data : mergedOptions.stringify(data);
    }
    const localFetch = typeof fetch != "undefined" ? fetch : fetchPolyfill;
    if (!localFetch) {
      throw new Error("No fetch function exists. Make sure to include a polyfill on Node.js.");
    }
    return localFetch(url, mergedOptions).then((response) => (
      // This is to get the response directly in the next then
      Promise.all([
        response,
        responseAs === "response" ? response : (
          // TODO: propagate error data to MandeError
          response[responseAs]().catch(() => null)
        )
      ])
    )).then(([response, dataOrError]) => {
      if (response.status >= 200 && response.status < 300) {
        return responseAs !== "response" && response.status == 204 ? null : dataOrError;
      }
      let err = new Error(response.statusText);
      err.response = response;
      err.body = dataOrError;
      throw err;
    });
  }
  const instanceOptions = {
    query: {},
    headers: {},
    ...passedInstanceOptions
  };
  return {
    options: instanceOptions,
    post: _fetch.bind(null, "POST"),
    put: _fetch.bind(null, "PUT"),
    patch: _fetch.bind(null, "PATCH"),
    // these two have no body
    get: (url, options) => _fetch("GET", url, null, options),
    delete: (url, options) => _fetch("DELETE", url, null, options)
  };
}
function nuxtWrap(api, fn) {
  const argsAmount = fn.length;
  const wrappedCall = function _wrappedCall() {
    let apiInstance = api;
    let args = Array.from(arguments);
    if (arguments.length === argsAmount) {
      apiInstance = { ...api };
      const [augmentApiInstance] = args.splice(0, 1);
      augmentApiInstance(apiInstance);
    }
    return fn.call(null, apiInstance, ...args);
  };
  return wrappedCall;
}
export {
  defaults,
  mande,
  nuxtWrap
};
/*! Bundled license information:

mande/dist/mande.mjs:
  (*!
    * mande v2.0.8
    * (c) 2024 Eduardo San Martin Morote
    * @license MIT
    *)
*/
//# sourceMappingURL=mande.js.map
